import java_cup.runtime.*;
import AST.*;

parser code {:
	
	Scanner scanner;
	AST raiz;	

	public parser(java.io.Reader input){
	scanner = new Scanner(input);
	
	}

public String errores(int sys)
{
	if (sys == 0)
		return("Class");
	else if (sys == 1)
		return("ID");
	else if (sys == 2)
		return("Llave_on");
	else if (sys == 3)
		return("Llave_off");
	else if (sys == 4)
		return("Public");
	else if (sys == 5)
		return("Static");
	else if (sys == 6)
		return("Else");
	else if (sys == 7)
		return("Void");
	else if (sys == 8)
		return("Main");
	else if (sys == 9)
		return("PARENT_on");
	else if (sys == 10)
		return("PARENT_off");
	else if (sys == 11)
		return("Corchete_on");
	else if (sys == 12)
		return("Corchete_off");
	else if (sys == 13)
		return("STRING");
	else if (sys == 14 )
		return("Extends");
	else if (sys ==15 )
		return("Return");
	else if (sys == 16)
		return("INT");
	else if (sys == 17)
		return("BOOLEAN");
	else if (sys == 18)
		return("If");
	else if (sys ==19 )
		return("DOTCOMMA");
	else if (sys ==20 )
		return("COMA");
	else if (sys == 21)
		return("Punto");
	else if (sys == 22)
		return("While");
	else if (sys == 23)
		return("System");
	else if (sys == 24)
		return("Out");
	else if (sys == 25)
		return("Println");
	else if (sys == 26)
		return("Lenght");
	else if (sys == 27)
		return("INTEGER_LITERAL");
	else if (sys ==28 )
		return("True");
	else if (sys == 29)
		return("False");
	else if (sys ==30 )
		return("This");
	else if (sys ==31 )
		return("New");
	else if (sys == 32)
		return("Negacion");
	else if (sys == 33)
		return("STRING_CONSTANT");
	else if (sys == 34)
		return("Suma");
	else if (sys == 35)
		return("Resta");
	else if (sys ==36 )
		return("MULT");
	else if (sys ==37 )
		return("Div");
	else if (sys ==38 )
		return("Diferencia");
	else if (sys == 39)
		return("Igual_Comp");
	else if (sys == 40)
		return("Igual_Asig");
	else if (sys == 41)
		return("Menor");
	else if (sys == 42)
		return("Menor_Igual");
	else if (sys ==43 )
		return("Mayor");
	else if (sys == 44)
		return("Mayor_Igual");
	else if (sys ==45 )
		return("OR");
	else if (sys ==46 )
		return("AND");
	else if (sys == 47)
		return("EOF");
	else if (sys == 48)
		return("ERROR");
	else if (sys == 49)
		return("NUM");
	else if (sys == 50)
		return("STR");
	else if (sys == 51)
		return("In");
	else if (sys == 52)
		return("Read");
	else if (sys == 53)
		return("Import");
	else if (sys == 54)
		return("Implements");
	else if (sys == 55)
		return("Exit");		
	else 
		return("error");
}

public void syntax_error(Symbol cur_token2)
{
	if (cur_token.sym == 0)
		report_error("No se esperaba un class", cur_token2);
	else if (cur_token.sym == 2)
		report_error("No se esperaba un ID", cur_token2);
	else if (cur_token.sym == 3)
		report_error("No se esperaba una llave abierta", cur_token2);
	else if (cur_token.sym == 4)
		report_error("No se esperaba una llave cerrada", cur_token2);
	else if (cur_token.sym == 5)
		report_error("No se esperaba un public", cur_token2);
	else if (cur_token.sym == 6)
		report_error("No se esperaba un else", cur_token2);
	else if (cur_token.sym == 7)
		report_error("No se esperaba un void", cur_token2);
	else if (cur_token.sym == 8)
		report_error("No se esperaba un main", cur_token2);
	else if (cur_token.sym == 9)
		report_error("No se esperaba un parentesis abierto", cur_token2);
	else if (cur_token.sym == 10)
		report_error("No se esperaba un parentesis cerrado", cur_token2);
	else if (cur_token.sym == 11)
		report_error("No se esperaba un corchete abierto", cur_token2);
	else if (cur_token.sym == 12)
		report_error("No se esperaba un cochete cerrado", cur_token2);
	else if (cur_token.sym == 13)
		report_error("No se esperaba un string", cur_token2);
	else if (cur_token.sym == 14)
		report_error("No se esperaba un extendes", cur_token2);
	else if (cur_token.sym == 15)
		report_error("No se esperaba un return", cur_token2);
	else if (cur_token.sym == 16)
		report_error("No se esperaba un int", cur_token2);
	else if (cur_token.sym == 17)
		report_error("No se esperaba un boolean", cur_token2);
	else if (cur_token.sym == 18)
		report_error("No se esperaba un if", cur_token2);
	else if (cur_token.sym == 19)
		report_error("No se esperaba un punto y coma", cur_token2);
	else if (cur_token.sym == 20)
		report_error("No se esperaba una coma", cur_token2);
	else if (cur_token.sym == 21)
		report_error("No se esperaba un punto", cur_token2);
	else if (cur_token.sym == 22)
		report_error("No se esperaba un while", cur_token2);
	else if (cur_token.sym == 23)
		report_error("No se esperaba un system", cur_token2);
	else if (cur_token.sym == 24)
		report_error("No se esperaba un out", cur_token2);
	else if (cur_token.sym == 25)
		report_error("No se esperaba un println", cur_token2);
	else if (cur_token.sym == 26)
		report_error("No se esperaba un length", cur_token2);
	else if (cur_token.sym == 27)
		report_error("No se esperaba un INTEGER_LITERAL", cur_token2);
	else if (cur_token.sym == 28)
		report_error("No se esperaba un true", cur_token2);
	else if (cur_token.sym == 29)
		report_error("No se esperaba un false", cur_token2);
	else if (cur_token.sym == 30)
		report_error("No se esperaba un this", cur_token2);
	else if (cur_token.sym == 31)
		report_error("No se esperaba una new", cur_token2);
	else if (cur_token.sym == 32)
		report_error("No se esperaba una negacion ", cur_token2);
	else if (cur_token.sym == 33)
		report_error("No se esperaba un STRING_CONSTANT", cur_token2);
	else if (cur_token.sym == 34)
		report_error("No se esperaba una suma", cur_token2);
	else if (cur_token.sym == 35)
		report_error("No se esperaba una resta ", cur_token2);
	else if (cur_token.sym == 36)
		report_error("No se esperaba una multiplicacion", cur_token2);
	else if (cur_token.sym == 37)
		report_error("No se esperaba una division", cur_token2);
	else if (cur_token.sym == 38)
		report_error("No se esperaba una diferencia", cur_token2);
	else if (cur_token.sym == 39)
		report_error("No se esperaba una comparacion", cur_token2);
	else if (cur_token.sym == 40)
		report_error("No se esperaba una asignacion", cur_token2);
	else if (cur_token.sym == 41)
		report_error("No se esperaba un menor ", cur_token2);
	else if (cur_token.sym == 42)
		report_error("No se esperaba un menor igual", cur_token2);
	else if (cur_token.sym == 43)
		report_error("No se esperaba un mayor", cur_token2);
	else if (cur_token.sym == 44)
		report_error("No se esperaba un mayor igual", cur_token2);
	else if (cur_token.sym == 45)
		report_error("No se esperaba un or", cur_token2);
	else if (cur_token.sym == 46)
		report_error("No se esperaba un and", cur_token2);
	else if (cur_token.sym == 47)
		report_error("No se esperaba un fin de linea", cur_token2);
	else if (cur_token.sym == 48)
		report_error("No se esperaba un ERROR", cur_token2);
	else if (cur_token.sym == 49)
		report_error("No se esperaba un numero", cur_token2);
	else if (cur_token.sym == 50)
		report_error("No se esperaba una string", cur_token2);
	else if (cur_token.sym == 51)
		report_error("No se esperaba una in", cur_token2);
	else if (cur_token.sym == 52)
		report_error("No se esperaba una read", cur_token2);
	else if (cur_token.sym == 53)
		report_error("No se esperaba un import", cur_token2);
	else if (cur_token.sym == 54)
		report_error("No se esperaba un implements", cur_token2);
	else if (cur_token.sym == 55)
		report_error("No se esperaba un exit", cur_token2);		
	else 
		report_error("Error: ", cur_token2);	
}

public void report_error(String message, Object info) {
	StringBuffer m = new StringBuffer("Error ");
	
	if (info instanceof java_cup.runtime.Symbol) {
		m.append( "(" + errores(cur_token.sym) +")" );
	     	m.append(" en fila "+ cur_token.left + " columna " + cur_token.right );
	     
	     	if (((java_cup.runtime.Symbol)info).value != null)
	       		m.append(". Lexema: " + cur_token.value.toString()); 
	}
	m.append(" : "+message);
	m.append(" y en su lugar viene " + ((java_cup.runtime.Symbol)info).value.toString());

	System.out.println(m);
}

   
public void report_fatal_error(String message, Object info) 	{
	report_error(message, info);
	throw new RuntimeException("Error Fatal de Sintaxis!!!");
}

:}

terminal Symbol ID;
terminal Symbol Llave_off;
terminal Symbol Llave_on;
terminal Symbol PARENT_off;
terminal Symbol PARENT_on;
terminal Symbol BOOLEAN;
terminal Symbol INT;
terminal Symbol DOTCOMMA;
terminal Symbol INTEGER_LITERAL;
terminal Symbol Corchete_off;
terminal Symbol Corchete_on;
terminal Symbol True;
terminal Symbol False;
terminal Symbol STRING_CONSTANT;
terminal Symbol Negacion;
terminal Symbol Suma;
terminal Symbol Resta;
terminal Symbol Public;
terminal Symbol Static;
terminal Symbol Extends;
terminal Symbol Return;
terminal Symbol If;
terminal Symbol COMA;
terminal Symbol Punto;
terminal Symbol While;
terminal Symbol System;
terminal Symbol Out;
terminal Symbol Println;
terminal Symbol Length;
terminal Symbol Else;
terminal Symbol Void;
terminal Symbol Main;
terminal Symbol STRING;
terminal Symbol MULT;
terminal Symbol Div;
terminal Symbol Diferencia;
terminal Symbol Igual_Comp;
terminal Symbol Class;
terminal Symbol This;
terminal Symbol New;
terminal Symbol Igual_Asig;
terminal Symbol Menor;
terminal Symbol Menor_Igual;
terminal Symbol Mayor;
terminal Symbol Mayor_Igual;
terminal Symbol OR;
terminal Symbol AND;
// terminal Symbol ERROR;
// terminal Symbol NUM;
// terminal Symbol STR;
terminal Symbol In;
terminal Symbol Read;
terminal Symbol Import;
terminal Symbol Implements;
terminal Symbol Exit;


non terminal Program;
non terminal ImportDecl;
non terminal ImportDecla;
non terminal ImportDecls;
non terminal ImportDeclsa;
non terminal TypeName;
non terminal TypeNames;
non terminal MainClass;
non terminal ClassDecl;
non terminal ClassDecla;
non terminal ClassDeclsa;
non terminal ClassDeclsb;
non terminal ClassDeclsc;
non terminal Statement;
non terminal Statementa;
non terminal Statementb;
non terminal Statementc;
non terminal Statementd;
non terminal Statements;
non terminal Statementsa;
non terminal BodyDecl;
non terminal Exp;
non terminal Exps;
non terminal Expsa;
non terminal Expsb;
non terminal ExpList;
non terminal ExpLists;
non terminal ExpListsa;
non terminal Type;
non terminal Types;
non terminal Typesa;
non terminal TypeNamesa;
non terminal VarDecl;
non terminal VarDecla;
non terminal ConstrDecl;
non terminal ConstrDecls;
non terminal ClassDecls;
non terminal MethodDecl;
non terminal MethodDecls;
non terminal MethodDecla;
non terminal MethodDeclb;
non terminal Exp_Simpl;
non terminal Op;
non terminal FormalList;


precedence left Return;
precedence left COMA;
precedence left Punto;
precedence left Class;
precedence left PARENT_on;
precedence left Else;
precedence left Llave_off;
precedence left Llave_on;
precedence left INT;
precedence left Suma;
precedence left Resta;
precedence left Div;
precedence left MULT;
precedence left Public;
precedence left BOOLEAN;
precedence left ID;

start with Program;

// Regla 01)
Program ::= ImportDecls:id ClassDecls:cd MainClass:mc
    {:
        parser.raiz = new ImpClssMnAST(id,cd,mc); ******************************************************
    :}
;

// Regla 02)
ImportDecls ::= ImportDecls:ids ImportDecl:id ; 
    {:
        RESULT = new varImportAST(s,d); ************************************************
    :} 
    | 
    {:
        RESULT = null;
    :}
;

// Regla 03)
ImportDecl ::= Import TypeName:tn ImportDeclA:id DOTCOMMA
    {:
        RESULT = new impTypeAST(tn,imp1); ***********************************************		
    :} 
;

// Regla 04)
TypeName ::= ID:i TypeNames:tn
    {:
        Symbol id = new Symbol(sym._id,ileft,iright,i);  ************************************
        RESULT = new varTypeNameAST(id,tn);         ****************
    :}
;

// Regla 05)
TypeNames ::= TypeNames:tn Punto ID:i
    {:
        Symbol id = new Symbol(sym._id,ileft,iright,i);  *******************************
        RESULT = new TNamesAST(id,tns); ***************
    :}
    |
    {:
        RESULT = null;
    :}
;

// Regla 06)
ImportDeclA ::= PuntoMULT     -> ImportDecl_1
    {:
        RESULT= new conPuntoAsteriscoAST();    *******************************************
    :}
    |
    {:
        RESULT= null;
    :}
;

// Regla 07) 
ClassDecls ::=  ClassDecls:cds ClassDecl:cd
    {:
        RESULT = new varClassDeclsAST(cd,cds); ****************************************
    :}
    | 
    {:
        RESULT = null;
    :}
;

// Regla 08)
ClassDecl ::= ClassDeclA:cd Llave_on BodyDecl:bd Llave_off  ;
    {:
        RESULT = new BodyCD1AST(cd,bd);    ******************************************
    :}
;

// Regla 09)
ClassDeclA ::= _class _id:i ClassDeclB:cd    -> ClassDecl_1
    {:
        Symbol id = new Symbol(sym._id,ileft,iright,i); ******************************** 
        RESULT = new CD2AST(id,cd);  **************************
    :}
    |
    {:
        RESULT = null;
    :}
;

// Regla 10)
ClassDeclB ::= ClassDeclC:cd ID:i  -> ClassDecl_2
    {:
        Symbol id = new Symbol(sym._id,ileft,iright,i); ********************************
        RESULT = new CD3AST(id,cd); ******************************************
    :}
;

// Regla 11)
ClassDeclC ::= Extends   -> ClassDecl_3
    {:
        RESULT = new conExtendsAST();  *****************************
    :}	
    | Implements
    {:
        RESULT = new conImplementsAST();  **************************
    :}
;

// Regla 12)
BodyDecl ::= BodyDecl:bd BodyDeclA:bda
    {:
        RESULT = new varBodyDeclAST(bda,bd);   *****************************
    :} 
    |
    {:	
        RESULT = null;
    :}
;

// Regla 13)
BodyDeclA ::= VarDecl:vd     -> BodyDecl_1
    {:
        RESULT = new VariableDAST(vd);  ************************
    :}
    | ConstrDecl:cd
    {:
        RESULT = new ConstructorDAST(cd);  ***************************
    :} 
    | MethodDecl:md
    {:
        RESULT = new MethodDAST(md);   ***********************
    :}
    | ClassDecl:cd
    {:
        RESULT = new ClassDAST(cd);   ****************************
    :}
;

// Regla 14)
VarDecl ::= Type:t ID:i  _puntoycoma  **************************************
    {:
        Symbol id = new Symbol(sym._id,i2left,i2right,i);  **********************
        RESULT = new TididAST(tp,id);   *********************
    :}
;

// Regla 15)
Type ::= _intcc
    {:
        RESULT = new TypeconIntccAST();
    :}
    | _boolean
    {:
        RESULT = new TypeconBooleanAST();
    :}
    | _int
    {:
        RESULT = new TypeconIntAST();
    :}       
    | _idT:i
    {:
        Symbol id = new Symbol(sym._idT,ileft,iright,i);
        RESULT = new TypeconIdAST(id);
    :}
;

// Regla 16)
ConstrDecl ::= Public ID:i PARENT_on  FormalList:fl PARENT_off Llave_on VarDecl:vd Statement:s Llave_off
    {:
        Symbol id = new Symbol(sym._id,ileft,iright,i); *****************
        RESULT = new DefConstrAST(id,fl,vd,s); ***************************
    :}	
;

// Regla 17)
VarDecls ::=	VarDecls:vds VarDecl:vd 
    {:
        RESULT = new varVarDeclsAST(vd,vds);   ********************************
    :}
    |
    {:
        RESULT = null;   
    :}
;

// Regla 18)
FormalList ::= Type:t ID:i FormalLists:fl
    {:
        Symbol id = new Symbol(sym._id,i2left,i2right,i); *********************************
        RESULT = new varFormalListAST(t,id,fl);       ***************************************
    :} 
    |
    {:
        RESULT = null;
    :}   
;

// Regla 19)
FormalLists ::=	 FormalLists:fl _coma Type:t _id:i
    {:
        Symbol id = new Symbol(sym._id,ileft,iright,i);
        RESULT = new varFormalListsAST(t,id,fl);
    :} 
    |  
    {:
        RESULT = null; 
    :} 
;

// Regla 20)
MethodDecl ::= Public IdAux:ia ID:i PARENT_on  FormalList:fl  PARENT_off Llave_on VarDecls:vd Statements:s Auxiliar:a Llave_off
    {:
        Symbol id = new Symbol(sym._id,ileft,iright,i);  **********************************
        RESULT = new DefMethodDeclAST(id,ia,fl,vd,s,a);   ******************************** 
    :} 	
;

// Regla 21)
IdAux ::=  Type:t
    {:
        RESULT = new conIdAST(t);
    :} 
    | _void
    {:
        RESULT = new conVoidAST();
    :}
;

// Regla 22)
Auxiliar ::=  _return Exp:e _puntoycoma
    {:
        RESULT = new DefReturnAST(e);
    :}  
    | 
    {:
        RESULT = null;
    :}
;

// Regla 23)
MainClass ::= Class ID:i1 Llave_on Public Static Void Main  PARENT_on  STRING Corchete_on ID:i2 PARENT_off Llave_on Statement:s Llave_off Llave_off
    {:
        Symbol i1 = new Symbol(sym._id,i1left,i1right,i1);    ************************************
        Symbol i2 = new Symbol(sym._id,i2left,i2right,i2); **************
        RESULT = new DefMainAST(i1,i2,s);  *************
    :}
;

// Regla 24)
Statement ::=	_id:i _igual ExpA:ea _puntoycoma
    {:
        Symbol id = new Symbol(sym._id,ileft,iright,i);
        RESULT = new asigStatAST(id,ea);
    :} 
    | IDAux:ia _punto _id:i _redondoizq ExpList:el _redondoder _puntoycoma
    {:
        Symbol id = new Symbol(sym._id,ileft,iright,i);
        RESULT = new ExplistStatAST(id,ia,el);
    :}     | _id:i Cuad_Exp:ce _igual Exp_Demas:ed _puntoycoma
    | _id:i ExpB:eb _igual ExpA:ea _puntoycoma
    {:
        Symbol id = new Symbol(sym._id,ileft,iright,i);
        RESULT = new ExpStatAST(id,eb,ea);
    :} 
    | _System _punto _exit _redondoizq _numero:n _redondoder _puntoycoma
    {:
        Symbol n = new Symbol(sym._numero,nleft,nright,n);
        RESULT = new exitStatAST(n1);
    :}
    |_corcheteizq Statements:s _corcheteder
    {:
        RESULT = new varStatAST(s);
    :}
    | _if _redondoizq Exp:e _redondoder Statement:s StatementA:ea
    {:
        RESULT = new ifelseStatAST(e,s,ea);
    :} 
    | _while _redondoizq Exp:e _redondoder Statement:s
    {:
        RESULT = new whileStatAST(e,s);
    :}
    | _System _punto _out _punto _println _redondoizq Exp:e _redondoder _puntoycoma
    {:
        RESULT = new printlnStatAST(e);
    :} 
;

// Regla 25)
ExpA ::=  Exp:e
    {:
        RESULT = new  solaExpAST(e);
    :}  
    | _redondoizq Type:t _redondoder _System _punto _in _punto _read _redondoizq _redondoder
    {:
        RESULT = new ExpReadAST(t);
    :}
;

// Regla 26)
Exp ::= ExpSimpl:es ExpI:ei
    {:
            RESULT = new DefExpAST(es,ei);
    :} 
;

// Regla 27)
ExpSimpl ::= _id:i
    {:
        Symbol id = new Symbol(sym._id,ileft,iright,i);
        RESULT = new Exp_SimplIdAST(id);
    :}
    | _true
    {:
        RESULT= new Exp_SimpltrueAST();
    :}
    | _false
    {:
        RESULT= new Exp_SimplfalseAST();
    :}
    | _numero:n
    {:
        Symbol nn = new Symbol(sym._numero,nleft,nright,n);
        RESULT= new Exp_SimplNumeroAST(nn);
    :}
    | _this
    {:
        RESULT= new Exp_SimplthisAST();
    :}
    | _new _TInt _cuadradoizq Exp:e _cuadradoder
    {:
        RESULT = new ExpnewIntAST(e);
    :} 
    | _new _id:i _redondoizq ExpList:e _redondoder
    {:
        Symbol id = new Symbol(sym._id,ileft,iright,i);
        RESULT = new ExpnewidAST(id,e);
    :} 
    | _negacion Exp:e
    {:
        RESULT = new ExpnegAST(e);
    :} 
    | _redondoizq Exp:e _redondoder
    {:
        RESULT = new ExpredAST(e);
    :} 
    | _String:s
    {:
        Symbol ss = new Symbol(sym._String,sleft,sright,s);
        RESULT = new Exp_SimplStringAST(ss);
    :}
;

// Regla 28)
ExpList ::= Exp:e ExpLists:el
    {:
        RESULT = new  ExplAST(e,el); 
    :} 
    | 
    {:
        RESULT = null;
    :} 
;

// Regla 29)
ExpLists ::= ExpLists:el _coma Exp:e
    {:
        RESULT = new varExpListsAST(e,el);
    :} 
    |  
    {:
        RESULT = null; 
    :} 
;

// Regla 30)
ExpI ::= Types:t ExpI:ei
    {:
        RESULT = new tipExpAST(t,ei);
    :} 
    | 
    {:
        RESULT = null; 
    :}  
;

// Regla 31)
Types ::=  _punto _id:i _redondoizq ExpList:el _redondoder
    {:
        Symbol id = new Symbol(sym._id,ileft,iright,i);
        RESULT = new TipoListaAST(id,el);
    :}
    | Op:o Exp:e
    {:
        RESULT = new TipoOpAST(o,e);
    :}  
    | _cuadradoizq Exp:e _cuadradoder
    {:
        RESULT = new TipoCuadrAST(e);
    :} 
    | _punto _length 
    {:
        RESULT= new TipoLengthAST();
    :}
;

// Regla 32)
StatementA ::= Else Statement:S
    {:
        RESULT = new elseStatAST(s);  *************************
    :} 
    |
    {:
        RESULT = null;
    :} 
;

// Regla 33)
IDAux ::=  _this 
    {:
        RESULT = new ThisconThisAST();
    :}
    | _id:i
    {:
        Symbol id = new Symbol(sym._id,ileft,iright,i);
        RESULT = new ThisconIDAST(id);
    :}
;

// Regla 34)
ExpB ::=  _cuadradoizq Exp:e _cuadradoder
    {:
        RESULT = new unaExpAST(e);
    :}  
;

// Regla 35)
Statements ::=	Statements:ss Statement:s 
    {:
        RESULT = new varStatementsAST(s,ss); 
    :} 
    |
    {:   
        RESULT = null;
    :}
;